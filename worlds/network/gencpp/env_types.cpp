/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "env_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace env {


Shape::~Shape() noexcept {
}


void Shape::__set_shape(const std::vector<int32_t> & val) {
  this->shape = val;
}

void Shape::__set_stride(const std::vector<int32_t> & val) {
  this->stride = val;
__isset.stride = true;
}

void Shape::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}
std::ostream& operator<<(std::ostream& out, const Shape& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Shape::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_shape = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->shape.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->shape.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->shape[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_shape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stride.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->stride.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readI32(this->stride[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stride = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->names.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readString(this->names[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_shape)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Shape::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Shape");

  xfer += oprot->writeFieldBegin("shape", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->shape.size()));
    std::vector<int32_t> ::const_iterator _iter15;
    for (_iter15 = this->shape.begin(); _iter15 != this->shape.end(); ++_iter15)
    {
      xfer += oprot->writeI32((*_iter15));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stride) {
    xfer += oprot->writeFieldBegin("stride", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->stride.size()));
      std::vector<int32_t> ::const_iterator _iter16;
      for (_iter16 = this->stride.begin(); _iter16 != this->stride.end(); ++_iter16)
      {
        xfer += oprot->writeI32((*_iter16));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter17;
      for (_iter17 = this->names.begin(); _iter17 != this->names.end(); ++_iter17)
      {
        xfer += oprot->writeString((*_iter17));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Shape &a, Shape &b) {
  using ::std::swap;
  swap(a.shape, b.shape);
  swap(a.stride, b.stride);
  swap(a.names, b.names);
  swap(a.__isset, b.__isset);
}

Shape::Shape(const Shape& other18) {
  shape = other18.shape;
  stride = other18.stride;
  names = other18.names;
  __isset = other18.__isset;
}
Shape& Shape::operator=(const Shape& other19) {
  shape = other19.shape;
  stride = other19.stride;
  names = other19.names;
  __isset = other19.__isset;
  return *this;
}
void Shape::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Shape(";
  out << "shape=" << to_string(shape);
  out << ", " << "stride="; (__isset.stride ? (out << to_string(stride)) : (out << "<null>"));
  out << ", " << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ")";
}


ETensor::~ETensor() noexcept {
}


void ETensor::__set_shape(const Shape& val) {
  this->shape = val;
}

void ETensor::__set_values(const std::vector<double> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const ETensor& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ETensor::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_shape = false;
  bool isset_values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->shape.read(iprot);
          isset_shape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->values.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readDouble(this->values[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          isset_values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_shape)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ETensor::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ETensor");

  xfer += oprot->writeFieldBegin("shape", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->shape.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->values.size()));
    std::vector<double> ::const_iterator _iter25;
    for (_iter25 = this->values.begin(); _iter25 != this->values.end(); ++_iter25)
    {
      xfer += oprot->writeDouble((*_iter25));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ETensor &a, ETensor &b) {
  using ::std::swap;
  swap(a.shape, b.shape);
  swap(a.values, b.values);
}

ETensor::ETensor(const ETensor& other26) {
  shape = other26.shape;
  values = other26.values;
}
ETensor& ETensor::operator=(const ETensor& other27) {
  shape = other27.shape;
  values = other27.values;
  return *this;
}
void ETensor::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ETensor(";
  out << "shape=" << to_string(shape);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


SpaceSpec::~SpaceSpec() noexcept {
}


void SpaceSpec::__set_shape(const Shape& val) {
  this->shape = val;
__isset.shape = true;
}

void SpaceSpec::__set_min(const double val) {
  this->min = val;
}

void SpaceSpec::__set_max(const double val) {
  this->max = val;
}

void SpaceSpec::__set_discreteLabels(const std::vector<std::string> & val) {
  this->discreteLabels = val;
__isset.discreteLabels = true;
}
std::ostream& operator<<(std::ostream& out, const SpaceSpec& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpaceSpec::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->shape.read(iprot);
          this->__isset.shape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->min);
          this->__isset.min = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->max);
          this->__isset.max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->discreteLabels.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->discreteLabels.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->discreteLabels[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.discreteLabels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpaceSpec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpaceSpec");

  if (this->__isset.shape) {
    xfer += oprot->writeFieldBegin("shape", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->shape.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("min", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->min);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->max);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.discreteLabels) {
    xfer += oprot->writeFieldBegin("discreteLabels", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->discreteLabels.size()));
      std::vector<std::string> ::const_iterator _iter33;
      for (_iter33 = this->discreteLabels.begin(); _iter33 != this->discreteLabels.end(); ++_iter33)
      {
        xfer += oprot->writeString((*_iter33));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpaceSpec &a, SpaceSpec &b) {
  using ::std::swap;
  swap(a.shape, b.shape);
  swap(a.min, b.min);
  swap(a.max, b.max);
  swap(a.discreteLabels, b.discreteLabels);
  swap(a.__isset, b.__isset);
}

SpaceSpec::SpaceSpec(const SpaceSpec& other34) {
  shape = other34.shape;
  min = other34.min;
  max = other34.max;
  discreteLabels = other34.discreteLabels;
  __isset = other34.__isset;
}
SpaceSpec& SpaceSpec::operator=(const SpaceSpec& other35) {
  shape = other35.shape;
  min = other35.min;
  max = other35.max;
  discreteLabels = other35.discreteLabels;
  __isset = other35.__isset;
  return *this;
}
void SpaceSpec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpaceSpec(";
  out << "shape="; (__isset.shape ? (out << to_string(shape)) : (out << "<null>"));
  out << ", " << "min=" << to_string(min);
  out << ", " << "max=" << to_string(max);
  out << ", " << "discreteLabels="; (__isset.discreteLabels ? (out << to_string(discreteLabels)) : (out << "<null>"));
  out << ")";
}


Action::~Action() noexcept {
}


void Action::__set_actionShape(const SpaceSpec& val) {
  this->actionShape = val;
__isset.actionShape = true;
}

void Action::__set_vector(const ETensor& val) {
  this->vector = val;
__isset.vector = true;
}

void Action::__set_discreteOption(const int32_t val) {
  this->discreteOption = val;
}
std::ostream& operator<<(std::ostream& out, const Action& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Action::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->actionShape.read(iprot);
          this->__isset.actionShape = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->vector.read(iprot);
          this->__isset.vector = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->discreteOption);
          this->__isset.discreteOption = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Action::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Action");

  if (this->__isset.actionShape) {
    xfer += oprot->writeFieldBegin("actionShape", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->actionShape.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vector) {
    xfer += oprot->writeFieldBegin("vector", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->vector.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("discreteOption", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->discreteOption);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Action &a, Action &b) {
  using ::std::swap;
  swap(a.actionShape, b.actionShape);
  swap(a.vector, b.vector);
  swap(a.discreteOption, b.discreteOption);
  swap(a.__isset, b.__isset);
}

Action::Action(const Action& other36) {
  actionShape = other36.actionShape;
  vector = other36.vector;
  discreteOption = other36.discreteOption;
  __isset = other36.__isset;
}
Action& Action::operator=(const Action& other37) {
  actionShape = other37.actionShape;
  vector = other37.vector;
  discreteOption = other37.discreteOption;
  __isset = other37.__isset;
  return *this;
}
void Action::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Action(";
  out << "actionShape="; (__isset.actionShape ? (out << to_string(actionShape)) : (out << "<null>"));
  out << ", " << "vector="; (__isset.vector ? (out << to_string(vector)) : (out << "<null>"));
  out << ", " << "discreteOption=" << to_string(discreteOption);
  out << ")";
}

} // namespace
